---
id: e011-02b-workman-compile-intent
title: "Workman compile_intent — Accept Raw Operation Data"
status: refined
tier: C
owner: benthepsychologist
goal: "Change workman.compile_intent() signature to accept raw operation data (op_name, payload, source, actor) instead of pre-built PMIntent. Function generates envelope internally (intent_id + issued_at), then compiles."
branch: feat/workman-envelope-generation
repo:
  name: workman
  url: /workspace/workman
created: "2026-02-17T00:00:00Z"
updated: "2026-02-17T12:00:00Z"
---

# e011-02b: Workman compile_intent — Accept Raw Operation Data

**Epic:** e011-pm-system | **Branch:** feat/workman-envelope-generation | **Tier:** E

## Objective

Change the signature of `workman.compile_intent()` to accept raw operation data instead of a pre-built PMIntent envelope. The function now authoritatively generates the envelope internally (intent_id with ULID format, issued_at timestamp), validates the actor, then compiles the operation against the PM schema.

This eliminates the need for a separate pm.build_intent job in lorchestra and aligns with future cloud architecture where pm-workers generate envelopes authoritatively.

## Problem

**Current flow (problematic):**
```
life pm.create → pm.build_intent job (generates id/timestamp) → pm.exec → workman.compile_intent(intent)
```

**Issue:** Running an entire lorchestra job just to generate an ID and timestamp is unnecessary overhead. The workman callable should handle envelope generation as part of its normal operation.

**Future cloud architecture concern:** In event-driven pm-worker systems, the worker (not the command plane) should authoritatively generate envelope metadata at the moment of operation creation. The command plane should only send raw operation data.

## Solution

**New flow (clean):**
```
life pm.create → pm.exec → workman.compile_intent(op_name, payload, source, actor)
```

Change `workman.compile_intent()` to:
1. Accept raw operation data parameters instead of pre-built intent
2. Validate actor_type enum ('human', 'system', 'ai') and actor_id
3. Generate intent envelope internally (intent_id, ops[], source, actor, issued_at)
4. Proceed with compilation as before
5. Return CallableResult with generated intent included for preview

## Current Implementation

**File:** `/workspace/workman/src/workman/intent.py`

**Current signature:**
```python
def compile_intent(intent: dict, ctx: dict = None) -> dict:
    """
    Compile a PM intent (operation + payload) against PM schema.

    Returns CallableResult with items (plans), diff, and plan_hash.
    """
```

**New signature (target):**
```python
def compile_intent(op_name: str, payload: dict, source: str, actor: dict, ctx: dict = None) -> dict:
    """
    Compile a PM operation from raw data by constructing intent envelope and validating against schema.

    Args:
        op_name: The PM operation name (e.g., 'pm.work_item.create')
        payload: Operation-specific payload fields (dict)
        source: Source of the operation (e.g., 'life-cli', 'system')
        actor: Actor who initiated the operation {'actor_type': str, 'actor_id': str}
        ctx: Optional execution context

    Returns:
        CallableResult dict with:
            - intent: Generated PMIntent envelope
            - items: List of plans generated by compilation
            - diff: Structured diff output
            - plan_hash: Hash of the compiled plan
            - stats: Execution statistics
            - schema_version: Schema version used

    Raises:
        CompileError: If actor_type is invalid, actor_id missing, or compilation fails
    """
```

## Proposed Implementation

### Phase 1: Update compile_intent Function

**File:** `/workspace/workman/src/workman/intent.py`

**Changes:**

1. Change function signature from `compile_intent(intent: dict, ctx: dict = None)` to `compile_intent(op_name: str, payload: dict, source: str, actor: dict, ctx: dict = None)`

2. Add envelope generation at the start of the function:
```python
from ulid import ULID
from datetime import datetime, timezone

def compile_intent(op_name: str, payload: dict, source: str, actor: dict, ctx: dict = None) -> dict:
    # Validate parameters
    if not op_name or not isinstance(op_name, str):
        raise CompileError("op_name must be a non-empty string")
    if not isinstance(payload, dict):
        raise CompileError("payload must be a dict")
    if not source or not isinstance(source, str):
        raise CompileError("source must be a non-empty string")
    if not isinstance(actor, dict):
        raise CompileError("actor must be a dict")

    # Validate actor structure
    if "actor_type" not in actor:
        raise CompileError("actor must have actor_type field")
    if "actor_id" not in actor:
        raise CompileError("actor must have actor_id field")

    # Validate actor_type enum
    valid_actor_types = ("human", "system", "ai")
    if actor["actor_type"] not in valid_actor_types:
        raise CompileError(f"actor_type must be one of {valid_actor_types}, got '{actor['actor_type']}'")

    # Generate intent envelope
    intent_id = f"pmi_{ULID()}"
    issued_at = datetime.now(timezone.utc).isoformat()

    intent = {
        "intent_id": intent_id,
        "ops": [{"op": op_name, "payload": payload}],
        "source": source,
        "actor": actor,
        "issued_at": issued_at,
    }

    # Continue with existing compilation logic against PM schema
    # (validate operation name, schema structure, etc.)
```

3. Update return structure to include the generated intent:
```python
    return {
        "intent": intent,  # NEW: return the generated envelope
        "items": plans,
        "diff": diff_output,
        "plan_hash": computed_hash,
        "stats": stats_dict,
        "schema_version": schema_version,
    }
```

### Phase 2: Update Docstring and Examples

Update the docstring to clearly document:
- New parameters (op_name, payload, source, actor)
- Intent generation behavior
- Actor validation rules
- Return structure with intent field
- Example usage

### Phase 3: Update Tests

**File:** `/workspace/workman/tests/test_intent.py`

Update all existing tests that call `compile_intent()`:

**Old call pattern:**
```python
intent = {
    "intent_id": f"pmi_{ULID()}",
    "ops": [{"op": "pm.work_item.create", "payload": {...}}],
    "source": "test",
    "actor": {"actor_type": "system", "actor_id": "test-system"},
    "issued_at": datetime.now(timezone.utc).isoformat(),
}
result = compile_intent(intent)
```

**New call pattern:**
```python
result = compile_intent(
    op_name="pm.work_item.create",
    payload={"title": "Test", "project": "P-01"},
    source="test",
    actor={"actor_type": "system", "actor_id": "test-system"}
)
```

Add new tests for:
- Actor validation: missing actor_type → raises CompileError
- Actor validation: missing actor_id → raises CompileError
- Actor validation: invalid actor_type → raises CompileError
- Parameter validation: empty op_name → raises CompileError
- Parameter validation: payload not dict → raises CompileError
- Intent generation: returned intent has correct structure
- Intent generation: intent_id has pmi_ prefix and ULID format
- Intent generation: issued_at is ISO 8601 UTC timestamp
- Intent generation: multiple calls generate unique intent_ids

### Phase 4: Update Lorchestra PM Jobs

**File:** `/workspace/lorchestra/lorchestra/jobs/definitions/pm/pm.exec.yaml`

Update the step that calls workman to pass raw operation data instead of pre-built intent:

**Old approach:**
```yaml
steps:
  - step_id: compile
    op: call
    params:
      callable: workman
      op: compile_intent
      intent: '@payload.intent'
```

**New approach:**
```yaml
steps:
  - step_id: compile
    op: call
    params:
      callable: workman
      op: compile_intent
      op_name: '@payload.op_name'
      payload: '@payload.payload'
      source: '@payload.source'
      actor: '@payload.actor'
```

The caller (pm.create, pm.update, pm.manage in life) now passes raw operation data to pm.exec, which forwards it to workman.compile_intent.

## Acceptance Criteria

**Function Signature**
- [ ] `compile_intent(op_name: str, payload: dict, source: str, actor: dict, ctx: dict = None)` is the new signature
- [ ] All 4 required parameters are non-optional (no defaults)
- [ ] Returns dict with intent, items, diff, plan_hash, stats, schema_version

**Parameter Validation**
- [ ] op_name must be non-empty string, else raises CompileError
- [ ] payload must be dict, else raises CompileError
- [ ] source must be non-empty string, else raises CompileError
- [ ] actor must be dict with actor_type and actor_id, else raises CompileError
- [ ] actor_type must be in ('human', 'system', 'ai'), else raises CompileError with clear message

**Envelope Generation**
- [ ] intent_id is generated with format `pmi_{ULID()}` (each call produces unique ID)
- [ ] issued_at is generated as ISO 8601 UTC timestamp using `datetime.now(timezone.utc).isoformat()`
- [ ] ops field is `[{"op": op_name, "payload": payload}]`
- [ ] source field is the passed source parameter
- [ ] actor field is the passed actor parameter

**Return Structure**
- [ ] Returns dict with key "intent" containing the generated envelope
- [ ] intent is included for preview/audit purposes (no separate call needed)
- [ ] items, diff, plan_hash, stats, schema_version are present as before
- [ ] CallableResult format is preserved

**Backwards Compatibility**
- [ ] Old tests updated to use new signature (no calls to compile_intent(intent) remain)
- [ ] All existing workman tests pass
- [ ] All lorchestra tests pass
- [ ] No external code calls compile_intent with old signature

**Integration**
- [ ] pm.exec.yaml successfully calls workman.compile_intent with new signature
- [ ] pm.exec receives intent in return value for audit/preview
- [ ] life pm.create/update/manage jobs forward raw data to pm.exec successfully

## Constraints

- **ULID dependency** - Use existing ulid import pattern (already used in build_intent reference code)
- **CompileError consistency** - Use existing workman.errors.CompileError for all validation failures
- **Actor validation** - Enforce actor_type enum ('human', 'system', 'ai') and require non-empty actor_id
- **No breaking changes to compilation logic** - The actual PM schema compilation (after envelope generation) remains unchanged
- **Return intent for audit** - Include generated intent in return dict so callers can see what was compiled

## Why This Change

**Simplification**: Eliminates unnecessary pm.build_intent lorchestra job. One less orchestration layer.

**Correctness**: Envelope generation (intent_id, timestamp) happens authoritatively in the domain logic (workman), not in the orchestration layer.

**Future alignment**: In cloud pm-worker architecture, the worker (running workman) should generate envelopes at operation creation time. Raw data flows into the worker; envelopes flow out with compiled results. This design supports that migration naturally.

**Performance**: Faster execution path — no extra job invocation needed.

## Implementation Path

1. Update function signature in intent.py
2. Add envelope generation logic and validation
3. Update return structure
4. Update all test calls to use new signature
5. Add new validation tests
6. Update docstring with examples
7. Update pm.exec.yaml to pass raw data
8. Run full test suite: `pytest workman/tests/ -v && pytest lorchestra/tests/ -v`
9. Verify no broken references to old signature

## Verification Checklist

```bash
# Verify signature change
python3 -c "from workman import compile_intent; import inspect; print(inspect.signature(compile_intent))"

# Run workman tests
python3 -m pytest workman/tests/test_intent.py -v

# Run lorchestra tests
python3 -m pytest lorchestra/tests/ -v

# Verify pm.exec can call workman with new signature
python3 -m lorchestra jobs show pm.exec
```
